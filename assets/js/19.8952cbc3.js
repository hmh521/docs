(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{387:function(s,a,t){s.exports=t.p+"assets/img/bulong.d6812e4d.png"},388:function(s,a,t){s.exports=t.p+"assets/img/lock.50e53bf5.png"},389:function(s,a,t){s.exports=t.p+"assets/img/expire.0a9f5144.png"},390:function(s,a,t){s.exports=t.p+"assets/img/RDB.3c22e3e2.png"},431:function(s,a,t){"use strict";t.r(a);var v=t(14),e=Object(v.a)({},(function(){var s=this,a=s._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"redis"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis"}},[s._v("#")]),s._v(" Redis")]),s._v(" "),a("h2",{attrs:{id:"redis-的使用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis-的使用场景"}},[s._v("#")]),s._v(" Redis 的使用场景")]),s._v(" "),a("ol",[a("li",[s._v("缓存")]),s._v(" "),a("li",[s._v("分布式锁")]),s._v(" "),a("li",[s._v("消息队列、延迟队列")])]),s._v(" "),a("h2",{attrs:{id:"缓存穿透"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缓存穿透"}},[s._v("#")]),s._v(" 缓存穿透")]),s._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[s._v("定义")]),s._v(" "),a("p",[s._v("查询一个不存在的数据，MySQL 查询不到数据也不会直接写入缓存，这会导致每次请求都查询数据库。")])]),s._v(" "),a("h4",{attrs:{id:"解决方案"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解决方案"}},[s._v("#")]),s._v(" 解决方案")]),s._v(" "),a("ol",[a("li",[a("p",[a("strong",[s._v("缓存空数据")]),a("br"),s._v("\n查询返回的数据为空时，仍将这个空数据写入缓存。"),a("br"),s._v("\n优点：可以防止缓存穿透。"),a("br"),s._v("\n缺点：缓存空数据可能会占用大量缓存空间。")])]),s._v(" "),a("li",[a("p",[a("strong",[s._v("布隆过滤器")])]),s._v(" "),a("ul",[a("li",[s._v("缓存预热：系统启动时，把所有可能的数据都加载到缓存中。")]),s._v(" "),a("li",[s._v("位图（bitmap）：相当于一个以位为单位的数组，数组中的每个元素只能是 0 或 1，用于判断某个元素是否存在。")])]),s._v(" "),a("p",[a("strong",[s._v("布隆过滤器用来判断一个元素是否存在于一个集合中。")])]),s._v(" "),a("ul",[a("li",[a("strong",[s._v("存储数据")]),s._v("：将数据通过多个哈希函数映射到位图中的多个位置，并将这些位置的值置为 1。")]),s._v(" "),a("li",[a("strong",[s._v("查询数据")]),s._v("：将数据通过多个哈希函数映射到位图中的多个位置，判断这些位置的值是否都为 1。")]),s._v(" "),a("li",[s._v("可能存在误判：数组越小误判率越高，数组越大误判率越低，但占用内存越大。误判率是可以设置的。")])])])]),s._v(" "),a("p",[a("img",{attrs:{src:t(387),alt:"布隆过滤器"}})]),s._v(" "),a("h4",{attrs:{id:"实现方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实现方式"}},[s._v("#")]),s._v(" 实现方式")]),s._v(" "),a("ul",[a("li",[s._v("Guava")]),s._v(" "),a("li",[s._v("Redisson")])]),s._v(" "),a("h4",{attrs:{id:"优缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优缺点"}},[s._v("#")]),s._v(" 优缺点")]),s._v(" "),a("ol",[a("li",[s._v("查询速度快 2. 占用内存少 3. 可能存在误判 4. 无法删除数据")])]),s._v(" "),a("h2",{attrs:{id:"缓存击穿"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缓存击穿"}},[s._v("#")]),s._v(" 缓存击穿")]),s._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[s._v("定义")]),s._v(" "),a("p",[s._v("缓存中的数据过期，大量请求同时查询数据库，导致数据库压力过大。")])]),s._v(" "),a("p",[s._v("解决方案:")]),s._v(" "),a("ol",[a("li",[s._v("互斥锁 性能差\n"),a("img",{attrs:{src:t(388),alt:"互斥锁"}})]),s._v(" "),a("li",[s._v("逻辑过期 不能保证数据绝对一致\n"),a("img",{attrs:{src:t(389),alt:"逻辑过期"}})])]),s._v(" "),a("h2",{attrs:{id:"缓存雪崩"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缓存雪崩"}},[s._v("#")]),s._v(" 缓存雪崩")]),s._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[s._v("定义")]),s._v(" "),a("p",[s._v("缓存中的数据同时过期，大量请求同时查询数据库，导致数据库压力过大。")])]),s._v(" "),a("p",[s._v("解决方案:")]),s._v(" "),a("ol",[a("li",[s._v("给不同的key设置不同的过期时间")]),s._v(" "),a("li",[s._v("利用Redis集群提高服务的高可用性  哨兵模式、集群模式")]),s._v(" "),a("li",[s._v("限流降级 nginx/gateway 保底策略")]),s._v(" "),a("li",[s._v("给业务添加多级缓存 Guava或Caffeine")])]),s._v(" "),a("h2",{attrs:{id:"双写一致性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#双写一致性"}},[s._v("#")]),s._v(" 双写一致性")]),s._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[s._v("定义")]),s._v(" "),a("p",[s._v("缓存和数据库的数据要保持一致。")])]),s._v(" "),a("p",[s._v("解决方案:")]),s._v(" "),a("blockquote",[a("p",[s._v("先删除缓存，还是先更新数据库？")])]),s._v(" "),a("p",[s._v("延迟双删策略 有可能会出现数据不一致")]),s._v(" "),a("p",[s._v("分布式锁 保证数据一致性")]),s._v(" "),a("p",[s._v("异步更新缓存 保证数据最终一致性  MQ的可靠性或者Canal中间件读取binlog  可以接收短暂延迟")]),s._v(" "),a("h2",{attrs:{id:"redis持久化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis持久化"}},[s._v("#")]),s._v(" redis持久化")]),s._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[s._v("定义")]),s._v(" "),a("p",[s._v("Redis 持久化是指将 Redis 在内存中的数据保存到硬盘中，以便在 Redis 重启后可以再次加载使用。")])]),s._v(" "),a("h3",{attrs:{id:"rdb-持久化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rdb-持久化"}},[s._v("#")]),s._v(" RDB 持久化")]),s._v(" "),a("p",[s._v("RDB 持久化是通过快照的方式来进行持久化的，当满足一定条件时，Redis 会自动将内存中的数据保存到硬盘中。")]),s._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[s._v("save "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("900")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 900 秒内有 1 个 key 发生变化")]),s._v("\nbgsave "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 异步保存")]),s._v("\n")])])]),a("h4",{attrs:{id:"执行原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#执行原理"}},[s._v("#")]),s._v(" 执行原理")]),s._v(" "),a("ol",[a("li",[s._v("Redis 会 fork 出一个子进程，子进程负责将内存数据写入到临时文件中。")]),s._v(" "),a("li",[s._v("页表: 内存中的数据是通过页表来管理的，子进程会复制一份父进程的页表，这样就可以保证子进程可以访问到父进程的所有数据。\n"),a("img",{attrs:{src:t(390),alt:"逻辑过期"}})])]),s._v(" "),a("h3",{attrs:{id:"aof-持久化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#aof-持久化"}},[s._v("#")]),s._v(" AOF 持久化")]),s._v(" "),a("p",[s._v("AOF 持久化是通过记录 Redis 服务器所处理的每一个写操作来记录数据库的变化。")]),s._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[s._v("appendonly "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("yes")]),s._v("\nappendfsync always "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 每次写入都同步")]),s._v("\nappendfsync everysec "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 每秒同步")]),s._v("\nappendfsync no "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 不同步")]),s._v("\nbgrewriteaof "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 重写AOF文件 最少的命令达到相同的效果")]),s._v("\n")])])]),a("p",[s._v("redis.conf 配置文件")]),s._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[s._v("appendonly "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("yes")]),s._v("\nappendfsync everysec\nauto-aof-rewrite-percentage "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("100")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 当AOF文件大小超过上次重写后的大小100%时，触发重写")]),s._v("\nauto-aof-rewrite-min-size 64mb "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# AOF文件大小超过64M时，触发重写")]),s._v("\n")])])]),a("p",[s._v("实际工作都是使用 RDB 和 AOF 混合使用，先读取 AOF 文件，再读取 RDB 文件。")]),s._v(" "),a("h2",{attrs:{id:"redis数据过期策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis数据过期策略"}},[s._v("#")]),s._v(" Redis数据过期策略")]),s._v(" "),a("blockquote",[a("p",[s._v("假如redis的key过期之后，会立即删除吗？")])]),s._v(" "),a("h3",{attrs:{id:"惰性删除"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#惰性删除"}},[s._v("#")]),s._v(" 惰性删除")]),s._v(" "),a("p",[s._v("当客户端访问某个 key 时，Redis 会检查这个 key 是否过期，如果过期则删除。")]),s._v(" "),a("p",[s._v("对内存不是很友好，可能会导致内存泄漏。")]),s._v(" "),a("h3",{attrs:{id:"定期删除"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#定期删除"}},[s._v("#")]),s._v(" 定期删除")]),s._v(" "),a("p",[s._v("Redis 默认每隔 100ms 就随机抽取一些 key 进行检查，如果过期则删除。")]),s._v(" "),a("p",[s._v("难以确定删除操作执行的时常和频率。")]),s._v(" "),a("p",[s._v("Redis 的过期键删除策略是惰性删除和定期删除的结合。")]),s._v(" "),a("h2",{attrs:{id:"redis的数据淘汰策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis的数据淘汰策略"}},[s._v("#")]),s._v(" Redis的数据淘汰策略")]),s._v(" "),a("blockquote",[a("p",[s._v("当 Redis 的内存不足时，会如何处理？")])]),s._v(" "),a("p",[s._v("LRU（Least Recently Used）：最近最少使用")]),s._v(" "),a("p",[s._v("LFU（Least Frequently Used）：最少频率使用")]),s._v(" "),a("p",[s._v("8种数据淘汰策略：")]),s._v(" "),a("ul",[a("li",[s._v("noeviction：默认策略，不会删除任何数据，直接返回错误。")]),s._v(" "),a("li",[s._v("volatile-lru：从设置了过期时间的数据集中删除最近最少使用的数据。")]),s._v(" "),a("li",[s._v("allkeys-random：从所有数据集中随机删除数据。")]),s._v(" "),a("li",[s._v("volatile-random：从设置了过期时间的数据集中随机删除数据。")]),s._v(" "),a("li",[s._v("volatile-ttl：从设置了过期时间的数据集中删除最快要过期的数据。")]),s._v(" "),a("li",[s._v("allkeys-lru：从所有数据集中删除最近最少使用的数据。")]),s._v(" "),a("li",[s._v("allkeys-lfu：从所有数据集中删除最不经常使用的数据。")]),s._v(" "),a("li",[s._v("volatile-lfu：从设置了过期时间的数据集中删除最不经常使用的数据。")])]),s._v(" "),a("ol",[a("li",[s._v("优先使用 allkeys-lru策略，如果有冷热数据区分")]),s._v(" "),a("li",[s._v("优先使用 allkeys-random策略，如果没有冷热数据区分")]),s._v(" "),a("li",[s._v("优先使用 volatile-lru策略，如果有置顶不设置过期时间的热数据")]),s._v(" "),a("li",[s._v("优先使用 allkeys-lfu/volatile-lfu 策略，如果短时间高频访问")])]),s._v(" "),a("blockquote",[a("p",[s._v("1.数据库有1000万数据，Redis只能缓存20万数据，如何保证热点数据都在内存中？")])]),s._v(" "),a("p",[s._v("使用allkeys-lru策略，将热点数据放在内存中。")]),s._v(" "),a("blockquote",[a("p",[s._v("2.redis的内存用完了会发生什么？")])]),s._v(" "),a("ol",[a("li",[s._v("内存淘汰策略")])]),s._v(" "),a("h2",{attrs:{id:"redis实现分布式锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis实现分布式锁"}},[s._v("#")]),s._v(" Redis实现分布式锁")]),s._v(" "),a("p",[s._v("使用场景:")]),s._v(" "),a("ol",[a("li",[s._v("需要结合项目中的业务进行回答，通常情况下，分布式锁用于解决并发问题。")])]),s._v(" "),a("ul",[a("li",[s._v("集群下的定时任务、抢单、幂等性场景。")])]),s._v(" "),a("h3",{attrs:{id:"使用原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用原理"}},[s._v("#")]),s._v(" 使用原理")]),s._v(" "),a("ol",[a("li",[s._v("setnx(key, value)：如果 key 不存在，则设置 key 的值为 value，返回 1；如果 key 存在，则返回 0。")])]),s._v(" "),a("div",{staticClass:"language-xml extra-class"},[a("pre",{pre:!0,attrs:{class:"language-xml"}},[a("code",[s._v("# 1. 加锁 NX 互斥 EX 过期时间\nSET KEY value NX EX 10\n# 2. 解锁\nDEL KEY\n")])])]),a("blockquote",[a("p",[s._v("redis分布式锁如何合理控制锁的有效时长？")])]),s._v(" "),a("ol",[a("li",[s._v("业务执行时间不确定，锁的有效时长应该大于业务执行时间。")]),s._v(" "),a("li",[s._v("锁续期")])]),s._v(" "),a("h3",{attrs:{id:"redission实现的分布式锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redission实现的分布式锁"}},[s._v("#")]),s._v(" redission实现的分布式锁")]),s._v(" "),a("ol",[a("li",[s._v("加锁后 每隔一段时间续期 (releaseTime - currentTime) / 3 每隔10秒续期一次")]),s._v(" "),a("li",[s._v("while循环不断尝试获取锁，直到获取锁成功或者超时 重试机制")]),s._v(" "),a("li",[s._v("加锁和设置过期时间都是基于Lua脚本实现的，保证原子性")]),s._v(" "),a("li",[s._v("redisson实现的分布式锁是可重入锁 跟当前的线程绑定 必须是同一个线程才能重入")]),s._v(" "),a("li",[s._v("利用hash结构 线程id和冲入次数")]),s._v(" "),a("li",[s._v("红锁： 不能只能一个节点加锁，需要多个节点加锁，（n/2）+ 1个节点加锁成功，才算成功 不能保证主从一致性")]),s._v(" "),a("li",[s._v("redis 保证ap 高可用  Zookeeper 保证cp 高一致性")])])])}),[],!1,null,null,null);a.default=e.exports}}]);
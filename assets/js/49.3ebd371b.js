(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{428:function(v,t,_){"use strict";_.r(t);var l=_(14),a=Object(l.a)({},(function(){var v=this,t=v._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"js-基础"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#js-基础"}},[v._v("#")]),v._v(" JS 基础")]),v._v(" "),t("ul",[t("li",[v._v("应用 桌面端应用，app端应用 也可以。")]),v._v(" "),t("li",[v._v("1995 出来 js  网景公司")]),v._v(" "),t("li",[v._v("ES6 2015 年  推出")]),v._v(" "),t("li",[v._v("JS 好用 ，学习成本高")]),v._v(" "),t("li",[v._v("末尾记得加分号，防止压缩报错。")])]),v._v(" "),t("div",{staticClass:"language-html extra-class"},[t("pre",{pre:!0,attrs:{class:"language-html"}},[t("code",[v._v("typeof // 检测数据类型\n")])])]),t("blockquote",[t("p",[v._v("类型根据值来的，属于弱类型。")])]),v._v(" "),t("h2",{attrs:{id:"定义变量"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#定义变量"}},[v._v("#")]),v._v(" 定义变量")]),v._v(" "),t("ol",[t("li",[v._v("解析器先分析，会存在变量提升。")]),v._v(" "),t("li",[v._v("var 会先定义，再赋值。 声明变量提升。")]),v._v(" "),t("li",[v._v("var 函数作用域。")]),v._v(" "),t("li",[v._v("let 必须声明后再使用，暂时性死区 TDC")]),v._v(" "),t("li",[v._v("新开辟空间服务，就近原则，和之前的没关。")]),v._v(" "),t("li",[v._v("不适用var定义，就是全局变量,会造成全局污染。")])]),v._v(" "),t("div",{staticClass:"language-html extra-class"},[t("pre",{pre:!0,attrs:{class:"language-html"}},[t("code",[v._v('"use strict" // 严格模式\n必须声明 \n关键词不能作为变量\n严格模式 作用域 是当前作用域查找\n')])])]),t("ul",[t("li",[v._v("const 常量 不能改变 大写 好区分 不能改变内存地址的引用。对象和数组的值是可以改的。 同一个作用域是不可以改的。")]),v._v(" "),t("li",[v._v("let 定义的值 不会改变 window     var 会改 window")]),v._v(" "),t("li",[v._v("var重复声明不会报错   let const 同一作用域不能重复声明。")])]),v._v(" "),t("h2",{attrs:{id:"浅拷贝和深拷贝"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#浅拷贝和深拷贝"}},[v._v("#")]),v._v(" 浅拷贝和深拷贝")]),v._v(" "),t("ul",[t("li",[v._v("浅拷贝  只复制某个对象的引用,而不复制对象本身,新旧对象还是共享同一块内存")]),v._v(" "),t("li",[v._v("深拷贝 深拷贝会创造一个一摸一样的对象,新对象和原对象不共享内存,修改新对象不会改变原对对象。")])]),v._v(" "),t("h2",{attrs:{id:"null-和-undefined"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#null-和-undefined"}},[v._v("#")]),v._v(" null 和 undefined")]),v._v(" "),t("p",[v._v("基本类型 undefined   引用类型  null "),t("br")]),v._v(" "),t("ul",[t("li",[v._v("函数没有返回值 undefined")]),v._v(" "),t("li",[v._v("未传参 undefined")]),v._v(" "),t("li",[v._v("type of  f  f不存在   undefined")]),v._v(" "),t("li",[v._v("num = num ||  5   不存在就是5   存在就是num")]),v._v(" "),t("li",[v._v("n++ 参与表达式是先参加后++；")]),v._v(" "),t("li",[v._v("1==true    true")]),v._v(" "),t("li",[v._v("||  && 短路运算符")]),v._v(" "),t("li",[v._v("a ||  b  为真的，赋值给前面变量 顺序很重要 把要判断的放前面")])]),v._v(" "),t("h2",{attrs:{id:"遍历"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#遍历"}},[v._v("#")]),v._v(" 遍历")]),v._v(" "),t("ul",[t("li",[v._v("for in  遍历数组  得到索引，对象 遍历的是键名")]),v._v(" "),t("li",[v._v("for of  新版遍历  遍历数组，字符串，必须是迭代对象。")]),v._v(" "),t("li",[v._v("Object.keys（），该方法返回对象自身属性名组成的数组。")])])])}),[],!1,null,null,null);t.default=a.exports}}]);
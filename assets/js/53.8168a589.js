(window.webpackJsonp=window.webpackJsonp||[]).push([[53],{435:function(v,_,a){"use strict";a.r(_);var t=a(14),s=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"jvm"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#jvm"}},[v._v("#")]),v._v(" JVM")]),v._v(" "),_("ul",[_("li",[v._v("请谈谈你对JVM的理解？ java8虚拟机和之前的变化更新？")]),v._v(" "),_("li",[v._v("什么是OOM？什么是栈溢出StackOverFlowError? 怎么分析？")]),v._v(" "),_("li",[v._v("JVM的常用调优参数有哪些？")]),v._v(" "),_("li",[v._v("内存快照如何抓取，怎么分析Dump文件？知道吗？")]),v._v(" "),_("li",[v._v("谈谈JVM中,类加载器")])]),v._v(" "),_("h2",{attrs:{id:"jvm位置"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#jvm位置"}},[v._v("#")]),v._v(" JVM位置")]),v._v(" "),_("ul",[_("li",[v._v("操作系统上的（运行虚拟机-）")])]),v._v(" "),_("h2",{attrs:{id:"jvm的体系结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#jvm的体系结构"}},[v._v("#")]),v._v(" JVM的体系结构")]),v._v(" "),_("h2",{attrs:{id:"类加载器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#类加载器"}},[v._v("#")]),v._v(" 类加载器")]),v._v(" "),_("p",[v._v("作用：加载class文件")]),v._v(" "),_("ol",[_("li",[v._v("ClassLoader 类加载器 加载，验证，准备，解析，初始化，使用，销毁")])]),v._v(" "),_("ul",[_("li",[v._v("虚拟机自带的加载器")]),v._v(" "),_("li",[v._v("启动类（根）加载器")]),v._v(" "),_("li",[v._v("扩展类记载器")]),v._v(" "),_("li",[v._v("应用程序加载器 null C 写的")])]),v._v(" "),_("h2",{attrs:{id:"双亲委派机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#双亲委派机制"}},[v._v("#")]),v._v(" 双亲委派机制")]),v._v(" "),_("p",[v._v("保证安全")]),v._v(" "),_("ol",[_("li",[v._v("APP->EXC->BOOT")]),v._v(" "),_("li",[v._v("向上委托 能加载就结束 否则 通知子加载器加载")])]),v._v(" "),_("h2",{attrs:{id:"沙箱安全机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#沙箱安全机制"}},[v._v("#")]),v._v(" 沙箱安全机制")]),v._v(" "),_("p",[v._v("限制程序运行的环境，以前默认远程代码是不安全的")]),v._v(" "),_("ul",[_("li",[v._v("字节码校验器")]),v._v(" "),_("li",[v._v("类装载器")]),v._v(" "),_("li",[v._v("存取控制器 存取权限")]),v._v(" "),_("li",[v._v("安全控制器 权限控制")]),v._v(" "),_("li",[v._v("安全软件包 keytools https")])]),v._v(" "),_("h2",{attrs:{id:"native"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#native"}},[v._v("#")]),v._v(" Native")]),v._v(" "),_("p",[v._v("调用底层C语言的库，会进入本地方法栈，调用JNI，本地方法接口，扩展Java的使用，融合不同的编程语言。")]),v._v(" "),_("ul",[_("li",[v._v("融合C和C++，必须要有调用C和C++的程序，想要立足")]),v._v(" "),_("li",[v._v("内存区域中专门开辟了一块标记区域，登记native方法")]),v._v(" "),_("li",[v._v("在最终执行的时候，加载本地方法库中的方法 通过JNI")])]),v._v(" "),_("p",[v._v("打印机")]),v._v(" "),_("h2",{attrs:{id:"pc寄存器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#pc寄存器"}},[v._v("#")]),v._v(" PC寄存器")]),v._v(" "),_("p",[v._v("每一个线程都有一个程序计数器，"),_("font",{staticStyle:{color:"#E8323C"}},[v._v("线程私有")]),v._v("，就是一个指针，指向方法区的方法字节码，在执行引擎读取下一条指令，非常小的内存空间，几乎可以忽略不计。")],1),v._v(" "),_("h2",{attrs:{id:"方法区"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#方法区"}},[v._v("#")]),v._v(" 方法区")]),v._v(" "),_("p",[v._v("线程共享，构造函数，接口，定义方法的信息")]),v._v(" "),_("p",[v._v("静态变量，常量，类信息，运行时的常量池存在方法区中，但是实例变量存在堆内存中")]),v._v(" "),_("p",[v._v("java 1.7 1.8 常量池在堆")]),v._v(" "),_("h2",{attrs:{id:"栈"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#栈"}},[v._v("#")]),v._v(" 栈")]),v._v(" "),_("p",[v._v("数据结构，先进先出。栈内存，主管程序的运行，生命周期和线程同步")]),v._v(" "),_("p",[v._v("两个方法互相调用，就会发生栈溢出")]),v._v(" "),_("p",[v._v("线程结束，栈内存也就是释放")]),v._v(" "),_("p",[v._v("对于栈来说不存在垃圾回收。")]),v._v(" "),_("p",[v._v("8大基本数据类型+对象引用+实例的方法")]),v._v(" "),_("p",[v._v("栈")]),v._v(" "),_("ul",[_("li",[v._v("方法索引（index）")]),v._v(" "),_("li",[v._v("输入输出参数（）")]),v._v(" "),_("li",[v._v("本地变量")]),v._v(" "),_("li",[v._v("引用")]),v._v(" "),_("li",[v._v("父帧")]),v._v(" "),_("li",[v._v("子帧")])]),v._v(" "),_("h2",{attrs:{id:"三种jvm"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#三种jvm"}},[v._v("#")]),v._v(" 三种JVM")]),v._v(" "),_("ul",[_("li",[v._v("Sun公司 HotSpot")]),v._v(" "),_("li",[v._v("BEA  JRockit 适合军事通信和")]),v._v(" "),_("li",[v._v("IBM  J9VM 跟硬件绑定")])]),v._v(" "),_("h2",{attrs:{id:"堆"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#堆"}},[v._v("#")]),v._v(" 堆")]),v._v(" "),_("p",[v._v("一个JVM，只有一个堆内存，堆内存的大小是可以调节的")]),v._v(" "),_("p",[v._v("类加载器读取了类文件后，一般会把什么放入堆中")]),v._v(" "),_("p",[v._v("类的实例对象，方法，常量1.8，变量")]),v._v(" "),_("h2",{attrs:{id:"新生区-老年群-永久区"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#新生区-老年群-永久区"}},[v._v("#")]),v._v(" 新生区 老年群 永久区")]),v._v(" "),_("p",[v._v("新生区")]),v._v(" "),_("ul",[_("li",[v._v("伊甸园（Eden Space）")]),v._v(" "),_("li",[v._v("幸存0区")]),v._v(" "),_("li",[v._v("幸存1区")])]),v._v(" "),_("p",[v._v("养老区")]),v._v(" "),_("p",[v._v("永久存储区（jdk8  元空间）")]),v._v(" "),_("p",[v._v("GC垃圾回收，主要在伊甸园区和养老区")]),v._v(" "),_("p",[v._v("内存满了 OOM 堆内存不够")]),v._v(" "),_("p",[v._v("新生区")]),v._v(" "),_("ul",[_("li",[v._v("一个类：诞生和成长的地方。甚至死亡")]),v._v(" "),_("li",[v._v("伊甸园区 new 对象的  满了 轻GC")]),v._v(" "),_("li",[v._v("幸存区的也满了就会进行重GC，进入养老")])]),v._v(" "),_("p",[v._v("永久区（用来存放jdk自身存在的Class对象，java运行时的一些环境和类信息）不存在垃圾回收，关闭虚拟机，释放内存，")]),v._v(" "),_("p",[v._v("元空间逻辑上存在，物理上不存在·")]),v._v(" "),_("ol",[_("li",[v._v("一个启动类加载了大量的第三方Jar包")]),v._v(" "),_("li",[v._v("Tomcat部署了太多的应用")]),v._v(" "),_("li",[v._v("大量动态生成的反射类，不断被加载")])]),v._v(" "),_("ul",[_("li",[v._v("jdk1.6  永久代  常量池在方法区中")]),v._v(" "),_("li",[v._v("jdk1.7 永久代  退化了 去永久代    常量池在堆中")]),v._v(" "),_("li",[v._v("jdk1.8  无永久代，常量池在元空间（元空间 ），元空间里面有方法区和常量池")])]),v._v(" "),_("h2",{attrs:{id:"字符串常量池在堆-运行时常量池在元空间"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#字符串常量池在堆-运行时常量池在元空间"}},[v._v("#")]),v._v(" 字符串常量池在堆，运行时常量池在元空间")]),v._v(" "),_("div",{staticClass:"language-json extra-class"},[_("pre",{pre:!0,attrs:{class:"language-json"}},[_("code",[v._v("long max = Runtime.getRuntime().maxMemory();"),_("span",{pre:!0,attrs:{class:"token comment"}},[v._v("// 试图使用的虚拟机内存")]),v._v("\nlong total = Runtime.getRuntime().totalMemory();"),_("span",{pre:!0,attrs:{class:"token comment"}},[v._v("// 返回jvm的初始化总内存")]),v._v("\n")])])]),_("h2",{attrs:{id:"堆内存调优"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#堆内存调优"}},[v._v("#")]),v._v(" 堆内存调优")]),v._v(" "),_("p",[v._v("默认分配的总内存是 电脑内存的4/1")]),v._v(" "),_("p",[v._v("初始化的内存 是64/1")]),v._v(" "),_("div",{staticClass:"language-json extra-class"},[_("pre",{pre:!0,attrs:{class:"language-json"}},[_("code",[v._v("-Xms1024m -Xmx1024m -XX"),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v(":")]),v._v("+PrintGCDetails\n"),_("span",{pre:!0,attrs:{class:"token comment"}},[v._v("// -Xms 初始化 默认 1/64")]),v._v("\n"),_("span",{pre:!0,attrs:{class:"token comment"}},[v._v("// -Xmx 设置最大分配内存，默认 1/4")]),v._v("\n"),_("span",{pre:!0,attrs:{class:"token comment"}},[v._v("// 能够看到第几行代码出错，内存快照分析工具，MAT，Jprofiler")]),v._v("\n"),_("span",{pre:!0,attrs:{class:"token comment"}},[v._v("// 分析Dump文件，快速定位内存泄漏问题")]),v._v("\n"),_("span",{pre:!0,attrs:{class:"token comment"}},[v._v("// 获得堆中的数据")]),v._v("\n"),_("span",{pre:!0,attrs:{class:"token comment"}},[v._v("// 获得大的对象")]),v._v("\n"),_("span",{pre:!0,attrs:{class:"token comment"}},[v._v("// Dump 文件")]),v._v("\n-Xms1m -Xmx8m -XX"),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v(":")]),v._v("+HeapDumpOnOutOfMemoryError\n"),_("span",{pre:!0,attrs:{class:"token comment"}},[v._v("// 最大任期时间 通过这个参数可以设定进入老年代的时间")]),v._v("\n-XX"),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v(":")]),v._v(" MaxTenuringThreshold="),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("5")]),v._v("\n")])])]),_("h2",{attrs:{id:"gc垃圾回收"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#gc垃圾回收"}},[v._v("#")]),v._v(" GC垃圾回收")]),v._v(" "),_("ul",[_("li",[v._v("轻GC和重GC")]),v._v(" "),_("li",[v._v("谁空谁是to")]),v._v(" "),_("li",[v._v("15次GC没有死进入养老区")])]),v._v(" "),_("p",[v._v("引用计数法：对象的引用次数，计数器本身也会有消耗。")]),v._v(" "),_("p",[v._v("复制算法：年轻代，有一个要是空的，（对象存活度较低）")]),v._v(" "),_("ul",[_("li",[v._v("好处：没有内存的碎片")]),v._v(" "),_("li",[v._v("坏处：浪费了内存空间")])]),v._v(" "),_("p",[v._v("标记清除法：扫描这些对象，对活着的进行标记。对没有标记的对象进行清除。")]),v._v(" "),_("ul",[_("li",[v._v("好处：不需要额外的空间！")]),v._v(" "),_("li",[v._v("坏处： 两次扫描，严重浪费时间，会产生内存碎片。")])]),v._v(" "),_("p",[v._v("标记清除压缩算法： 压缩防止内存碎片产生，再次扫描，向一端移动存活的对象，多了一个移动成本")]),v._v(" "),_("p",[_("font",{staticStyle:{color:"rgb(77, 77, 77)"}},[v._v("分代收集算法：是根据对象的生命周期，把内存作分代，然后在分配对象的时候，不同生命周期的对象放在不同的代里面，不同的代上使用合适的回收算法进行回收")])],1),v._v(" "),_("h2",{attrs:{id:"jmm-抽象的概念"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#jmm-抽象的概念"}},[v._v("#")]),v._v(" JMM(抽象的概念)")]),v._v(" "),_("p",[v._v("javaMemoryModel")]),v._v(" "),_("p",[v._v("java内存模型")]),v._v(" "),_("p",[v._v("缓存一致性协议，用于定义数据读写的规则")]),v._v(" "),_("p",[v._v("JMM定义了线程工作内存 和主内存之间的抽象关系，线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存.")]),v._v(" "),_("p",[v._v("volatile保证共享对象的可见性,synchronized")]),v._v(" "),_("p",[_("strong",[_("font",{staticStyle:{color:"rgb(51, 51, 51)"}},[v._v("happens-before规则,")])],1),_("font",{staticStyle:{color:"rgb(51, 51, 51)"}},[v._v("happens-before仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前 。")])],1),v._v(" "),_("h2",{attrs:{id:"总结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[v._v("#")]),v._v(" 总结")]),v._v(" "),_("p",[v._v("内存效率：复制算法>标记清除算法>标记压缩算法（时间复杂度）")]),v._v(" "),_("p",[v._v("内存整齐度： 复制算法 = 标记压缩算法 >标记清除算法")]),v._v(" "),_("p",[v._v("内存利用率：标记压缩算法 = 标记清除算法 > 复制算法")]),v._v(" "),_("p",[v._v("没有最好的算法，但是只有最合适的。")]),v._v(" "),_("p",[v._v("分代收集算法：")]),v._v(" "),_("p",[v._v("年轻代：")]),v._v(" "),_("ul",[_("li",[v._v("存活率低")]),v._v(" "),_("li",[v._v("复制算法！")])]),v._v(" "),_("p",[v._v("老年代：")]),v._v(" "),_("ul",[_("li",[v._v("区域大：存活率高")]),v._v(" "),_("li",[v._v("标记清除（内存碎片不是很多）加标记压缩混合 实现")])])])}),[],!1,null,null,null);_.default=s.exports}}]);